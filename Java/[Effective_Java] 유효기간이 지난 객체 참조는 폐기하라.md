## 유효기간이 지난 객체 참조는 폐기하라
### 메모리 누수에 대해 신경써야 한다.

------

```java
    public class Stack {
        private Object[] elements;
        private int size = 0;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;

        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }

        public Object pop() {
            if (size== 0)
                throw new EmptyStackException();
            return elements[--size];
        }

        // 적어도 하나 이상의 원소를 담을 공간을 보장한다.
        // 배열의 길이를 늘려야 할 때마다 대략 두 배씩 늘인다.
        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
```

위 스택은 뚜렷이 잘못된 부분은 없다. 그러나 이 프로그램에는 보이지 않는 문제가 존재한다.  
이 프로그램에는 **메모리 누수(memory leak)** 문제가 있다. 그 결과로 쓰레기 수집기가 해야할 일이 많아져서 성능이 저하되거나, 메모리 요구량이 증가할 것이다.

#### 어디서 메모리 누수가 생겼을까???  
메모리 누수는 스택이 커졌다가 줄어들면서 제거한 객체들을 쓰레기 수집기가 처리하지 못해서 생긴다. 스택을 사용하는 프로그램이 그 객체들을 더 이상 참조하지 않는데도 말이다. 스택이 그런 객체에 대한 **만기 참조**를 제거하지 않기 때문이다. **만기 참조란, 다시 이용되지 않을 참조를 말한다.**  
방금 살펴본 스택의 경우에는 elements 배열에서 실제로 사용되는 부분(active portion)을 제외한 나머지 영역에 보관된 참조들이 만기 참조이다. 첨자 값이 size보다 작은 곳에 있는 요소들은 실제로 쓰이는 참조들이지만, 나머지 영역에 있는 참조들은 그렇지 않다.  
실수로 객체 참조를 계속 유지하는 경우, 해당 객체만 쓰레기 수집에서 제외는 것이 아니라 그 객체를 통해 참조되는 다른 객체들도 쓰레기 수집에서 제외된다. 따라서 만기 참조가 몇 개라도 있으면 굉장히 많은 객체가 쓰레기 수집에서 제외될 가능성이 있다.

위의 스택 프로그램은 간단하게 고칠 수 있다. 쓸 일이 없는 객체 참조는 무조건 null로 만드는 것이다. 스택에서 pop된 객체에 대한 참조는 그 즉시 null로 만들면 된다. 즉 아래와 같이 바꿔주면 된다.
```java 
    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        Object results = elements[--size];
        elements[size] = null; //만기 참조 제거
        return results;
    }
```
위와 같이 만기 참조를 null로 만들면 나중에 실수로 그 참조를 사용하더라도 NullPointerException이 발생하기 때문에, 프로그램은 오작동하는 대신 바로 종료된다는 장점이 있다.

객체 참조를 null 처리하는 것은 규범이라기보단 예외적인 조치가 되어야 한다. 만기 참조를 제거하는 가장 좋은 방법은 해당 참조가 보관된 변수가 유효범위를 벗어나게 두는 것이다. 변수를 정의할 떄 그 유효범위를 최대한 좁게 만들면 자연스럽게 해결된다.

자체적으로 관리하는 메모리가 있는 클래스를 만들 때는 메모리 누수가 발생하지 않도록 주의해야 한다. 더 이상 사용되지 않는 원소 안에 있는 객체 참조는 반드시 null로 바꿔 주어야 한다.

캐시(cache)도 메모리 누수가 흔히 발생하는 장소다. 객체 참조를 캐시 안에 넣어 놓고 잊어버리는 일이 많기 때문이다. 이 문제에는 몇 가지 해결책이 있다.  
1. WeackHashMap을 가지고 캐시를 구현하는 것이다. 캐시 바깥에서 키를 참조하고 있을 때만 값을 보관하면 될 때 쓸 수 있는 전략이다. 키에 대한 참조가 만기 참조가 되는 순간 캐시 안에 보관된 키-값 쌍은 자동으로 삭제되기 때문이다. WeakHashMap은 캐시 안에 보관되는 항목의 수명이 키에 대한 외부 참조의 수명에 따라 결정되는 상황에만 적용 가능하다는 것을 기억하자.
2. 캐시에 보관되는 항목의 수명은 캐시에 보관된 기간에 따라 결정되는 것이 보통이다., 후면 스레드를 사용해 처리할 수도 있고, 캐시에 새로운 항목을 추가할 떄 처리할 수도 있다. LinkedHashMap 클래스를 사용하면 이 접근법을 구현하기 좋은데, removeEldestEntry 메소드가 제공되기 때문이다.

**메모리 누수가 흔히 발견되는 또 한 곳은 리스너 등의 역호출자(callback)다.** 역호출자 등록 기능을 제공하는 API를 사용하는 클라이언트가 역 호출자를 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태로 남아있게 된다.  
쓰레기 수집기가 역호출자를 즉시 처리하도록 할 가장 좋은 방법은, 역 호출자에 대한 약한 참조만 저장하는 것이다.

--------

참고 :

Bloch, Joshua. Effective Java (2/E). 인사이트, 2014