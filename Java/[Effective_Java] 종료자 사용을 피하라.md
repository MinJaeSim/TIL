## 종료자(finalizer) 사용을 피하라
### 종료자는 예측 불가능하며, 대체로 위험하고, 일반적으로 불필요하다.

----

종료자를 사용하면 시스템 오류, 성능 문제, 이식성 문제가 발생할 수 있다. **종료자 사용은 피하는 것이 원칙이다.** 종료자의 단점은, 즉시 실행되리라는 보장이 전혀 없다는 것이다. 어떤 객체에 대한 모든 참조가 사라지고 나서 종료자가 실행되기까지는 긴 시간이 걸릴 수 있다. 따라서 긴급한(time-critical) 작업을 종료자 안에서 처리하면 안 된다. 예를 들어, 종료자 안에서 파일을 닫도록 하면 치명적이다. 파일 기술자는 유한한 자원이기 때문이다.
종료자 실행시점은 쓰레기 수지비기 알고리즘에 좌우되는데, 이 알고리즘은 JVM 구현마다 크게 다르다. 따라서 종료자 실행시점에 의존하는 프로그램은 JVM마다 다르게 동작한다.

클래스에 종료자를 붙여 놓으면, 드물지만 객체 메모리 반환이 지연될 수도 있다. 자바 언어 명세서(specification)에는 어떤 스레드가 종료자를 실행해야 하는지 아무 언급도 없으므로, 이식성을 보장하면서 이 문제를 해결할 방법은 없다. 종료자 사용을 피하는 것만이 유일한 해결책이다.  
자바 명세에는 종료자가 즉시 실행되어야 한다는 문구도 없지만, 종료자가 결국에는 반드시 실행되어야 한다는 문구도 없다. 따라서 종료자가 실행되지 않은 객체가 남은 상태로 프로그램이 끝나게 되는 일도 충분히 가능하다. 그러므로 지속성이 보장되어야 하는 **중요 상태 정보(critical persistent state)는 종료자로 갱신하면 안 된다.** 

**종료자를 사용하면 프로그램 성능이 심각하게 떨어진다.** 간단한 객체를 만들고 삭제하는 데는 5.6ns면 충분한데, 종료자를 붙이자 그 시간은 2400ns로 늘어났다. 즉 종료자를 사용해 객체를 삭제하는 프로그램은 430배 가량 느려진것을 확인 할 수 있다.  
파일이나 스레드처럼 명시적으로 반환하거나 삭제해야 하는 자원을 포함하는 객체의 클래스는 그냥 **명시적인 종료 메소드(termination method)를 하나 정의**하고, 더 이상 필요하지 않는 객체라면 클라이언트가 해당 메소드를 호출하도록 해라. 한 가지 명심할 것은, 종료 여부를 객체 안에 보관해야 한다는 것. 즉, 유효하지 않은 객체임을 표시하는 private 필드를 하나 두고, 모든 메소드 맨 앞에 해당 필드를 검사하는 코드를 두어, 이미 종료된 객체에 메소드를 호출하면 IllegalStateException이 던져지도록 해야 한다는 것이다. 이런 명시적 종료 메소드의 예로는 OutputStream이나 InputStream, java.sql.Connection에 정의된 close 메소드가 있다.  

**이런 명시적 종료 메소드는 객체 종료를 보장하기 위해 보통 try-finally 문과 함께 쓰인다.** 명시적 종료 메소드를 finally 문 안에서 호출하도록 해 놓으면 객체 사용 과정에서 예외가 던져져도 종료 메소드가 실행되도록 만들 수 있다.
```java
    Foo foo = new Foo();
    try {
        ...
    } finally {
        foo.terminate(); // 명시적 종료 메소드 호출
    }
    // 자바 1.7부터는 try-with-resources 문을 지원하는데,
    // 이 문법을 이용하면 finally 블록은 사용하지 않아도 된다.
```

종료자가 적합한 두 가지 경우가 있다. 하나는, **명시적 종료 메소드 호출을 잊을 경우에 대비하는 안전망(safety net)으로서의 역할이다.** 종료자가 언제 호출될 지는 알 수 없기 때문에 자원 반환이 늦어지기는 하겠지만, 클라이언트가 명시적 종료 메소드 호출을 잊더라도 어쨋든 자원은 반환된다. 하지만 **종료자는 그런 자원을 발견하게 될 경우 반드시 경고 메시지를 로그로 남겨야 한다.** 클라이언트 코드에 버그가 있는 것이므로, 고치도록 알려야 하기 때문이다. 종료자로 이런 안전망을 구현하려 할 때는, 추가적인 비용을 감당하면서 구현할 만한 가치가 있는 일인지 신중하게 생각하기 바란다.  
종료자 사용이 적합한 두 번째 경우는 **네이티브 피어(native peer)와 연결된 객체를 다룰 때다.** 네이티브 피어는 일반 자바 객체가 네이티브 메소드를 통해 기능 수행을 위임하는 네이티브 객체를 말한다. 네이티브 피어는 일반 객체가 아니므로, 쓰레기 수집기가 알 수 없을 뿐더러 자바 측 피어 객체가 반환될 때 같이 반환할 수도 없다. 네이티브 피어가 중요한 자원을 점유하고 있지 않다고 가정한다면, 종료자는 그런 객체의 반환에 걸맞다. 네이티브 피어가 즉시 종료되어야 하는 자원을 포함하는 경우에는, 앞서 설명한 대로 명시적인 종료 메소드를 클래스에 추가해야 한다.  
주의할 것 하나는, "종료자 연결(finalizer chaining)"이 자동으로 이루어지지 않는다는 것이다. 만일 어떤 클래스가 종료자를 갖고 있고 하위 클래스가 해당 메소드를 재정의하는 경우, 하위 클래스의 종료자는 상위 클래스의 종료자를 명시적으로 호출해야 한다. 이때 하위 클래스의 상태는 try 블록 안에서 종료시켜야 하고, 상위 클래스 종료자는 finally 블록 안에서 호출해야 한다.

```java
    // 종료 보호자 숙어(Finalizer Guardian idiom)
    @Override
    protected void finalize() throw Throwable {
        try {
            ... // 하위 클래스의 상태를 종료함
        } finally {
            super.finalize();
        }
    }
```

하위 클래스에서 상위 클래스 종료자를 재정의하면서 상위 클래스 종료자 호출을 잊으면, 상위 클래스 종료자는 절대로 호출되지 않는다. 이런 문제를 방지하는 한 가지 방법은, 종료되어야 하는 모든 객체마다 여벌의 객체를 하나 더 만드는 것이다. 종료되어야 하는 객체의 클래스안에 종료자를 정의하는 대신, 익명 클래스 안에 종료자를 정의하는 것이다.  
이 익명 클래스의 목적은 해당 클래스의 객체를 포함하는 객체를 종료시키는 것이다. 이 익명 클래스로 만든 객체는 **종료 보호자(finalizer guardian)** 라고 부르는데, 종료되어야 하는 객체 안에 하나씩 넣는다. 종료 보호자의 바깥 객체에는 종료 보호자를 참조하는 private 필드가 있다. 따라서 바깥 객체에 대한 모든 참조가 사라지는 순간, 종료 보호자의 종료자도 실행 가능한 상태가 된다. 이 보호자 객체의 종료자는 필요한 종료 작업을, 마치 바깥 객체의 종료자인 것처럼 수행한다.

```java
    public final Object finalizerGuardian = new Object() {
        @Override
        protected void finalize() throws Throwable {
            ... // 바깥 Foo 객체를 종료시킴
        }
    }
```

public 클래스 Foo에는 종료자가 없다는 것에 유의하자. 따라서 하위 클래스의 종료자가 상위 클래스의 종료자를 호출하건 말건 상관 없다. 이 기법은 종료자가 상위 클래스의 종료자를 호출하건 말건 상관 없다. 이 기법은 종료자가 있는 비-fianl 클래스를 구현할 때 반드시 고려해야 한다.

요약
자원 반환에 대한 최종적 안전장치를 구현하거나, 그다지 중요하지 않는 네이티브 자원을 종료시키려는 것이 아니라면 종료자는 사용하지 말라.  
굳이 종료자를 사용해야 하는 드문 상황에 처했다면 super.finalize 호출은 잊지 말자. 자원 반환 안전망을 구현하는 경우에는 종료자가 호출될 때마다 클라이언트 코드가 잘못 작성되었음을 알리는 메시지를 로그로 남기자.  
하위 클래스 정의가 가능한 public 클래스에 종료자를 추가해야 하는 상황이라면, 하위 클래스에서 실수로 super.finalize 호출을 잊어도 종료 작업이 진행될 수 있도록 종료 보호자 패턴을 도입하면 좋을지 고려 해보자.

-----

참고: 

Bloch, Joshua. Effective Java (2/E). 인사이트, 2014