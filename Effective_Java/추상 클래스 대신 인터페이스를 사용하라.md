# 추상 클래스 대신 인터페이스를 사용하라
### 다양한 구현이 가능한 자료형을 정의하는 방법과 인터페이스의 올바른 사용법에 대해 알아본다.

-----

## 자바에는 여러 가지 구현을 허용하는 자료형을 만드는 방법이 2가지 있다. 
## - 인터페이스와 추상 클래스(abstract class)가 그것이다.  

이 두 방법의 가장 분명한 차이는, **추상 클래스는 구현된 메소드를 포함할 수 있지만 인터페이스는 아니라는것**이다. (자바 8부터는 'default' 메소드를 통해 인터페이스에도 구현을 일부 포함시킬 수 있음)  

더 중요한 차이는, 추상 클래스가 규정하는 자료형을 구현하기 위해서는 추상 클래스를 반드시 계승해야 한다는 것이다. 인터페이스의 경우에는 인터페이스에 포함된 모든 메소드를 정의하고 인터페이스가 규정하는 일반 규약을 지키기만 하면 되며, 그렇게 만든 클래스는 클래스 계층에 속할 필요가 없다.  

**이미 있는 클래스를 개조해서 새로운 인터페이스를 구현하도록 하는 것은 간단하다.** 그러나 새로 도입된 추상 클래스를 확장하도록 기존 클래스를 개조할 수는 없다.

## 인터페이스는 믹스인(mixin)을 정의하는 데 이상적이다.
간다히 말해서 믹스인은 클래스가 주 자료형 이외에 추가로 구현할 수 있는 자료형으로, 어떤 선택적 기능을 제공한다는 사실을 선언하기 위해 쓰인다.

## 인터페이스는 비 계층적인 자료형 프레임워크를 만들 수 있도록 한다.
인터페이스를 사용하면 포장 클래스 숙어(wrapper class idiom)을 통해 안전하면서도 강력한 기능 개선이 가능하다.  
추상 클래스를 사용해 자료형을 정의하면 프로그래머는 계승 이외의 수단을 사용할 수 없다. 그렇게 해서 만든 클래스는 포장 클래스보다 강력하지도 않고, 깨지기 쉽다.

## 추상 골격 구현(abstract skeletal implementation) 클래스를 중요 인터페이스마다 두면, 인터페이스의 장점과 추상 클래스의 장점을 결합할 수 있다.
인터페이스로는 자료형을 정의하고, 구현하는 일은 골격 구현 클래스에 맡기면 된다. 관습적으로 골격 구현 클래스의 이름은 AbstractInterface와 같이 정한다. Interface는 해당 클래스가 구현하는 인터페이스의 이름이다.  
ex) AbstractCollection, AbstractSet, AbstractList, ...

골격 구현 클래스를 적절히 정의한다면, 프로그래머는 쉽게 인터페이스를 구현할 수 있다. 예를 들어, 아래의 정적 팩토리 메소드는 기능적으로 완전한 List를 구현한다.

    static List<Integer> intArrayAsList(final int[] a) {
        if (a == null)
            throw new NullPointerException();
        
        return new AbstractList<Integer>() {
            public Integer get(int i) {
                retrun a[i];
            }

            @Override
            public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;
                return oldVal;
            }

            public int size() {
                return a.length;
            }
        };
    }

위 코드는 int 배열을 Integer 객체의 리스트처럼 볼 수 있도록 하는 *어댑터(Adapter) 패턴 적용 사례*이기도 하다. int 값과 Integer 객체 사이의 *자동 변환 과정 때문에 성능은 좋지 않다*. 정적 팩토리 메소드를 통해 반환되는 객체의 클래스가 정적 팩토리 안에 숨겨진, *외부에서는 접근이 불가능한 익명 클래스라는 점에 주의*해야한다.

추상 클래스를 자료형 정의 수단으로 사용했을 때 만족해야 하는 제약사항들을 따르지 않아도 추상 클래스를 구현할 수 있도록 돕는다는 것이 골격 구현 클래스의 아름다움이다. 골격 구현 클래스가 있다면 해당 클래스를 사용해 인터페이스를 구현하는 것이 가장 분명한 프로그래밍 방법이다.  
하지만 엄밀히 말해서 그것도 선택사항일 뿐이다. 골격 구현 클래스를 상속하도록 기존 클래스를 변경할 수 없다면, 인터페이스를 직접 구현해도 된다. 그리고 그럴 때도 골격 구현 클래스를 사용하면 더 쉽게 구현할 수 있다.  
골격 구현 클래스를 계승하는 private 내부 클래스를 정의하고, 인터페이스 메소드에 대한 호출은 해당 중첩 클래스 객체로 전달(forwarding)하는 것이다. 

#### 다양한 구현을 허용하는 자료형을 추상 클래스로 정의하면 인터페이스보다 나은점이 한 가지 있는데, 인터페이스보다는 *추상 클래스가 발전시키기 쉽다*는 것이다.


## 인터페이스는 자료형을 정의할 때만 사용하라
#### 인터페이스를 구현하는 클래스를 만들게 되면, 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형(Type) 역할을 하게된다. 인터페이스를 구현해 클래스를 만든다는 것은, 해당 클래스의 객체로 어떤 일을 할 수 있는지 클라이언트에게 알리는 행위다. 다른 목적으로 인터페이스를 정의하고 사용하는 것은 적절치 못하다.

이 기준에 미달하는 사례로는 상수 인터페이스(constant interface)라는 것이 있다. 이런 인터페이스에는 메소드가 없고, static final 필드만 있다. 모든 필드는 상수 정의다. **상수 인터페이스 패턴은 인터페이스를 잘못 사용한 것이다.** 

### 상수를 API 일부로 공개하고 싶을 때, 해당 상수가 이미 존재하는 클래스나 인터페이스에 강하게 연결되어 있을 때는 그 상수들을 해당 클래스나 인터페이스에 추가해야 한다. 
### 위의 경우가 아닐 때에는 객체 생성이 불가능한 유틸리티 클래스에 넣어서 공개해야 한다. 

    package com.effrvtivejava.science;
    
    public class PhysicalConstants {
        private PhysicalConstants() {} // 객체 생성을 막음
        
        public static final double AVOGADROS_NUMBER = 6.02214199e23;
        public static final double ELECTRON_MASS = 9.10938188e-31;
    }

보통 이런 유틸리티 클래스를 사용하면 클라이언트는 상수 앞에 PhysicalConstants.AVOGADROS_NUMBER 와 같이 클래스 이름을 붙여야 한다. 하지만 자바 5부터 도입된 정적 임포트(static import) 기능을 사용하면 클래스 이름을 제거할 수 있다.

    import static com.effrvtivejava.science;
   
    public class Test {
        double atoms(double mols) {
            return AVOGADROS_NUMBER * mols;
        }
    }

-------
## 요약 

### 인터페이스는 다양한 구현이 가능한 자료형을 정의하는 일반적으로 가장 좋은 방법이다. 다만 개선이 쉬운 API를 만드는 것이 중요한 경우에는 추상 클래스를 사용해야 하는데, 그 단점은 잘 이해하고 있어야 한며 그 단점을 수용할 수 있는 경우로 한정해서 사용해야 한다.  

### 중요한 인터페이스를 API에 포함시키는 경우에는 골격 구현 클래스를 함께 제공하면 어떨지 심각하게 고려해봐야 한다. 

### public 인터페이스는 극도로 주의해서 설계해야 하며, 실제로 여러 구현을 만들어 보면서 광범위하게 테스트해야 한다.

### 인터페이스는 자료형을 정의할 때만 사용해야한다. 특정 상수를 API의 일부로 공개할 목적으로는 적절치 않다.

-------

참고도서 : Bloch, Joshua. Effective Java (2/E). 인사이트, 2014