# C로 공부하는 자료구조
### 알고리즘 성능 분석 방법과 C언어 개념

-------

## 알고리즘 성능 분석
알고리즘의 효율성을 따져보는 방법이 알고리즘의 복잡도 분석이다. 알고리즘의 분석에서는 2가지의 측면을 고려할 수 있다. 알고리즘의 실행 시간 분석을 **시간 복잡도(Time Complexity)**, 알고리즘이 사용하는 기억 공간 분석을 **공간 복잡도(Space Complexity)** 라고 한다. 알고리즘의 복잡도를 얘기할때는 대게 시간 복잡도를 말한다.

알고리즘의 시간 복잡도는 알고리즘이 실행하는 연산의 수를 의미한다. 보통 연산의 실행 횟수는 프로그램에 주어지는 입력의 개수 n에 따라 변한다. 연산의 개수를 입력의 개수 n의 함수로 나타낸 것을 **시간 복잡도 함수** 라고 하고 *T(n)*이라고 표기한다.

## 표기법
일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡하다. 하지만 대게 입력의 개수가 많은 경우 차수가 가장 큰 항이 영향을 크게 미치고 다른 항들은 상대적으로 무시될 수 있다.

#### 1. 빅오 표기법
시간 복잡도 함수에서 불필요한 정보를 제거하여 알고리즘 분석을 쉽게 할 목적으로 시간 복잡도를 표시하는 방법을 **빅오 표기법(big-oh notation)**이라고 한다. 빅오 표기법의 수학적 정의는 다음과 같다.

*두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n>=(n_0)에 대하여 |f(n)| <= c|g(n)|을 만족하는 2개의 상수 c와 n_0가 존재하면 f(n) = O(g(n))이다.*

예를 들어 f(n)이 2n^2 + 3n + 1 이고 g(n)이 n^2이라면 n>= n_0일 때 부등식 |2n^2 + 3n + 1| <= c|n^2|를 만족하는 c와 n_0의 쌍은 (6,1), (5,2), (4,3), ... 등이 가능하다. 따라서 위의 정의에 의하여 2n^2 + 3n + 1 = O(n^2)이라 할 수 있다. 간단한 방법은 다항식으로 기본 연산이 표현됬을 경우 다항식의 최고차 항만을 남기고 나머지 항들은 버리는 것이다.

빅오 표기법에 의한 알고리즘의 실행 시간을 비교하면 아래와 같다.

O(1) < O(logN) < O(n) < O(nlogN) < O(n^2) < O(2^n) < O(n!)

#### 2. 빅 오메가
빅오 표기법은 상한을 표기한 것이다. 이로 인한 문제점은 f(n) = 2n + 1 인 경우 f(n) = O(n)이지만 O(n^2) 라고도 할 수 있다. 상한은 여러 개가 존재할 수 있기 때문이다. 빅 오메가(big omega)는 이러한 문제점을 보완하기 위한 것이다. 빅 오메가는 어떤 함수의 하한을 표시하는 방법이다. f(n)을 빅 오메가로 나타내면 f(n)은 n>= 1 에 대해 2n + 1 > n 이므로 = Ω(n)이다.

#### 3. 빅 세타
빅 세타는 동일한 함수로 상한과 하한을 만들 수 있는 경우, 즉 위에서 본 f(n)과 같은 경우를 f(n) = Θ(n)이라고 한다.


## C언어 개념 - 구조체
구조체는 타입이 다를 수 있는 데이터를 묶는 방법이다. 선언과 생성하는 방법은 아래와 같다.
```c
// 정의방법
struct 구조체명 {
    항목 1;
    항목 2;
};

// 생성 방법
struct 구조체명 변수이름;
```

만약 typedef를 사용하게 되면 구조체를 새로운 타입으로 선언하는 것이 가능하다.
```c
// 정의 방법
typedef struct person {
    char name[10];
    int age;
    float height;
} person;

// 생성 방법
person a;
```

구조체의 변수에 접근하는 방법은 '.'을 사용하면 되는데 이를 항목 연산자라 한다.
```
a.age = 26;
a.height = 176;
```

#### 자체 참조 구조체(self-referential structure)
자체 참조 구조체는 특별한 구조체로서 구성 요소 중에 자기 자신을 가리키는 포인터가 한 개 이상 존재하는 구조체를 의미한다. 이 자체 참조 구조체는 연결 리스트나 트리를 구성할 때 많이 등장한다. 일반적으로 항목의 개수를 미리 예측 할 수 없는 경우에 자체 참조 구조체를 정의해 놓고 동적으로 기억장소를 할당받아서 이들을 포인터로 연결하여 자료 구조를 구성한다. 아래의 코드는 ListNode 구조체에서 link 필드가 ListNode를 가리키므로 자체 참조 구조체이다.
```c
typedef struct ListNode {
    char data[10];
    struct ListNode *link;
} ListNode;
```
구조체를 요소로 하는 배열도 생성 가능하고, 구조체를 포함한 구조체도 선언 가능하다.

## C언어 개념 - 포인터
포인터 변수는 다른 변수의 주소를 가지고 있는 변수이다. 포인터는 여러 가지 타입의 대상에 대하여 선언 가능하다.
```c
    void *p;            // 아무것도 가리키지 않은 포인터
    int *pi;            // 정수 변수를 가리키는 포인터
    float *pf;          // 실수 변수를 가리키는 포인터
    char *pc;           // 문자 변수를 가리키는 포인터
    int **pp;           // 포인터를 가리키는 포인터
    struct test *ps;    // test 구조체를 가리키는 포인터
    void (*f)(int);     // f는 int를 매개 변수로 갖고 반환 값을 갖지 않는 함수를 가리키는 포인터
```

구조체에 대한 포인터는 다른 데이터 타입과 다르지 않지만 한가지 주의해야 할 점이 있다.
```c
    struct {
        int i;
        float f;
    } s, *ps;

    ps = &s;
    ps->i = 2;
    ps->f = 3.14;
```
위에서와 같이 구조체의 멤버에 접근하는 표기법은 "->" 이다. ps->i 는 (*ps).i와 같은 효과를 가진다. 사이즈가 큰 구조체 자체를 매개 변수로 넘기는 것은 상당히 부담이 될 수 있다. 구조체 포인터를 넘기게 되면 주소만 함수에 전달되고, 함수는 이 포인터를 이용하여 구조체의 내용을 변경할 수 있다.

변수의 주소뿐 아니라 함수의 주소를 담는 포인터 변수를 만들 수 있다.
```c
    void foo(int a) {
        printf("foo : %d\n", a);
    }

    void main() {
        void (*f)(int);
        f = foo;
        f(10);      // == foo(10)
        (*f)(10);   // == f(10);
    }

    // foo(10) === f(10) === (*f)(10)
```
포인터 사용시 주의할 점은 아래와 같다.
1. 포인터가 어떤 값을 가리키고 있지 않을 때는 NULL로 설정하는 것이 좋다.
2. 포인터가 초기화가 안 된 상태에서 포인터가 가리키는 곳에 자료를 저장하면 안된다.

## C언어 개념 - 동적 메모리 할당
#### 1. void *malloc(int size)
size 바이트만큼의 메모리 블록을 할당한다. 새로운 메모리 블록의 시작 주소(포인터)를 반환한다. 반환되는 포인터의 타입은 void * 이므로 이를 적절한 타입의 포인터로 변환 시켜야 한다. 메모리 확보가 불가능하면 NULL을 반환한다.

#### 2. void *calloc(int num, int size)
배열 형식의 메모리를 할당한다. 배열 요소의 크기는 size 바이트이고, 개수는 num이 된다. 요소들은 0으로 초기화된다는 점이 특징이다. 반환 값은 malloc과 동일하다.