# C로 공부하는 자료구조
### 순환 (Recursion)

----------

## 순환이란?
어떤 알고리즘이나 함수가 자기 자신을 호출하여 문제를 해결하는 기법을 순환이라 한다. 순환은 본질적으로 순환적으로 정의된 문제나 자료 구조를 다루는 프로그램에 적합하다. 예를 들어 정수의 팩토리얼 n!은 n*(n-1)! 로 정의할 수 있다. n!을 정의하는데 다시 (n-1)!이 사용되었는데, 이러한 정의를 순환적이라 한다.

```c
    // 순환을 이용한 팩토리얼 계산
    int factorial(int n) {
        if (n <=1) return 1;
        else return (n * factorial(n-1));
    }
```

### 순환의 예 - 피보나치 수열 계산
순환을 사용하여 코드를 작성하면 단순하게 작성 가능하고 가독성도 높아진다. 그러나 똑같은 계산을 여러번 반복하게 되어 계산 시간이 엄청나게 길어 지게되는데, 피보나치 수열이 대표적인 예이다.

```c
    int fib(int n) {
        if (n==0)
            return 0;
        else if (n==1)
            return 1;
        else
            return (fib(n-1) + fib(n-2));
    };
```
위의 코드가 피보나치 수열 계산 프로그램이다. 매우 단순하고 이해하기 쉽지만 비효율적이다. 만약 fib(6)을 호출하였을 경우 fib(6),fib(5)은 1번, fib(4)는 2번 fib(3)은 3번, fib(2) 는 5번, fib(1)은 8번, fib(0)은 5번이 계산된다. fib()함수는 총 25번 호출되고, 같은 계산이 여러번 호출되는것을 확인할 수 있다. 만약 fib(25)를 호출 한다면 거의 25만번, fib(30)의 경우 약 300만번 fib()함수가 호출이 된다. 따라서 피보나치 수열의 경우 반복을 사용하면 훨씬 좋은 결과를 얻을 수 있다.

```c
    int fib_iter(int n) {
        if (n < 2)
            return n;
        else {
            int i, tmp, cur = 1, last = 0;
            for (i = 2; i <= n; i++) {
                tmp = cur;
                cur += last;
                last = tmp;
            }
            return cur;
        }
    }
```

### 순환의 예 - 하노이탑
순환을 이용하면 순환이 일어날 수록 문제의 크기가 작아져야 한다. 하노이탑의 경우 순환의 사용을 가장 잘 보여줄 수 있는 문제다. 하노이탑 문제를 해결하는 기본 개념은 아래와 같다.

1. A의 n-1개의 원판을 B로 옮긴다.
2. A의 제일 밑에 있는 원판을 C로 옮긴다.
3. B의 n-1개 원판을 C로 옮긴다.

위의 개념을 순환을 사용하여 코드를 작성하면 아래와 같다.

```c
    void hanoi_tower(int n, char from, char tmp, char to) {
        if (n==1) 
            printf("원판 1을 %c에서 %c로 옮긴다.\n", from, to);
        else {
            hanoi_tower(n-1, from, to, tmp);
            printf("원판 %d을 %c에서 %c로 옮긴다.\n", n, from, to);
            hanoi_tower(n-1, tmp, from, to);
        }
    }
```

## 순환과 반복
순환과 비슷한 동작으로는 반복(iteration)이 존재한다. 반복이란 for 나 while 등의 반복 구조를 사용하여 코드를 작성하는 것이다. 반복 횟수를 가지고 일정 횟수 동안 반복시킬 수도 있고 어떤 조건이 만족될 때까지 계속하여 반복하도록 할 수도 있다. 반복은 많은 경우, 간명하고 효율적으로 되풀이를 구현하는 방법이다.
```c
    // 반복을 이용한 팩토리얼 계산
    int factorial_iter(int n) {
        int k, v = 1;
        for(k = n; k > 0; k--) 
            v *= k;
        return v;
    }
```

반복과 순환은 대부분 서로 교체 가능하다. 그러나 순환을 이용한 알고리즘을 반복을 이용한 알고리즘으로 바꾸기 어려운 경우가 있다. 

1. return n * factorial(n-1);
2. return factorial(n-1) * n;

1의 경우를 꼬리 순환(tail recursion), 2의 경우를 머리 순환(head recursion)이라 한다. 꼬리 순환의 경우 반복을 이용한 알고리즘으로 형태 변환이 가능하다. 그러나 머리 순환의 경우나 하노이탑과 같이 여러 군데에서 자기 자신을 호출하는 경우(multi recursion)는 쉽게 반복적인 코드로 바꿀 수 없다.

그러나 때때로 반복을 사용하게 되면 오히려 복잡해지는 문제들도 존재한다. 이러한 경우 순환이 좋은 해결책이 될 수 있다.

순환과 반복중에 어떤 형태가 더 바람직한지는 문제에 따라 달려있다. 대게의 경우 순환으로 작성된 코드가 더 가독서이 높고 간결하다. 순환적인 형태의 문제의 예로는 팩토리얼 계산, 피보나치 수열, 이항 계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이탑 등이 있다. 그러나 순환으로 작성된 코드는 반복으로 작성된 코드보다 실행 시간이 오래 걸릴 가능성과 기억 공간의 사용량이 높다.

### 순환적인 방법이 더 빠른 예
팩토리얼 계산의 경우 반복이 순환보다 더 빠른 방법이다. 그렇지만 거듭제곱 값을 계산하는 경우 순환의 방법이 더 빠르다.

반복을 이용한 알고리즘
```c
    double power_iter(double x, int n) {
        int i;
        double r = 1.0;
        for(i = 0; i<n; i++)
            r *= x;
        return r;
    }
```

순환을 이용한 알고리즘
```c
    double power_recur(double x, int n) {
        if (n == 0) 
            return 1;
        else if ((n%2)==0)
            return power_recur(x*x, n/2);
        else 
            return x*power_recur(x*x, (n-1)/2);
    }
```
두 개의 알고리즘을 이용하여 2^500을 1000000번 실행해보면 반복을 이요한 알고리즘은 7.11초가 걸리고, 순환을 이용한 알고리즘은 0.47가 걸린다. 

순환을 이용한 알고리즘은 한번 함수를 호출할 때마다 문제의 크기가 절반으로 줄어든다. 2^k를 구한다고 가정하면, 함수를 한번 호출할 때마다 2^k -> 2^(k-1) -> 2^(k-2) -> ... -> 2^1 -> 2^0 로 줄어든다. 즉 약 k번의 순환 호출이 일어남을 알 수 있다. n=2^k 이라 하고 양변에 log를 취하면 log_2(n) = k 임을 알 수 있다. 전체 연산의 수는 log_2(n) = k에 비례하게 될 것이고 따라서 시간복잡도는 O(log_2(n) = k)가 된다.

반면에 반복을 이용한 알고리즘은 n번의 루프를 돌게 되고 시간 복잡도는 O(n)이 된다.